/*
 * SPI-Master interface.
 *
 * Copyright (C) 2014-2015 Dmitry Podkhvatilin <vatilin@gmail.com>
 *
 * This file is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You can redistribute this file and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software Foundation;
 * either version 2 of the License, or (at your discretion) any later version.
 * See the accompanying file "COPYING.txt" for more details.
 *
 * As a special exception to the GPL, permission is granted for additional
 * uses of the text contained in this file.  See the accompanying file
 * "COPY-UOS.txt" for details.
 */
#ifndef __SPI_MASTER_INTERFACE_H__
#define __SPI_MASTER_INTERFACE_H__

//
//        Интерфейс драйвера контроллера SPI в режиме "Мастер"
//
//    Данный заголовочный файл предназначен для унификации интерфейса драйверов
// контроллеров SPI различных производителей. Унификация интерфейса нужна для
// возможности написания ПЕРЕНОСИМЫХ драйверов контроллеров более высокого 
// уровня, использующих SPI в качестве технологической линии связи (например, 
// драйвер флеш-памяти SD в режиме SPI, драйверы различных EEPROM, подключаемых 
// по SPI, драйвер USB-контроллера MAX3421 и т.д.).
//
//    Для разработки драйвера SPI, совместимого с данным интерфейсом, необходимо
// выполнить несколько шагов:
//
// 1) Объявить структуру драйвера SPI, "наследующую" данную структуру, т.е.
// содержащую в качестве первого поля переменную структуры spimif_t, например:
//
//    struct _manufacturer_spim_t {
//
//       spimif_t        spimif;
//
//       ... // другие поля, необходимые для драйвера SPI.
//    };
//    typedef struct _manufacturer_spim_t manufacturer_spim_t;
//
// Имя структуры, разумеется, может быть произвольным.
//
// 2) Написать функцию приёма-передачи для данного контроллера SPI вида:
//
//    int manufacturer_trx (spimif_t *spi, spi_message_t *msg)
//    {
//          // Преобразуем указатель к структуре нашего аппаратного драйвера
//          // (мы уверены, что нам передают указатель на правильную структуру).
//          manufacturer_spim_t *mspi = (manufacturer_spim_t *) spi;
//
//          ... // Код, реализующий обмен. Используется структура аппаратного
//              // драйвера для хранения нужной для работы информации.
//    }
//
// Необходимо учитывать, что информация о скорости передачи и режиме работы
// контроллера содержится в структуре сообщения spi_message_t, а не в структуре
// драйвера.
// Функция должна возвращать коды результата, объявленные в данном файле.
// Если поле msg->tx_data равно 0, то в линию должно быть выдано msg->word_count
// нулей.
// Если поле msg->rx_data равно 0, то принятые данные должны быть отброшены.
//
// 3) Написать функцию инициализации драйвера SPI. Параметры могут быть любыми,
// данным интерфейсом они никак не регламентируются. Но логично, что одним из
// параметров должен быть указатель на структуру драйвера, содержащую в себе 
// структуру spimif_t. Таким образом, функция инициализации должна выглядеть
// примерно так:
//
//    int manuf_spi_init(manufacturer_spim_t *spi, ...)
//    {
//          spi->spimif.trx = manufacturer_trx;
//          ...
//    }
//
// В функции инициализации обязательно должен быть установлен указатель на 
// функцию приёма-передачи.
//
// 4) Для драйверов SPI предусмотрено макроопределение SPI_NO_DMA, которое,
// если задано, предполагает отключение использования каналов прямого доступа 
// в драйвере SPI. Реализовывать ли такую реакцию на данное макроопределение
// или нет - решение лежит на разработчике конкретного драйвера SPI.
//
// В качестве примеров можно использовать драйверы SPI для процессоров фирмы
// Элвис и Миландр: sources/elvees/spi.*, sources/milandr/spi.* .
//
//
//    Использование драйвера:
//
// 1) Объявить переменную структуры драйвера SPI:
//      manufacturer_spim_t spim;
// 2) Вызвать для неё функцию инициализации. Логично, если это произойдёт в
// функции uos_init(), хотя это и не обязательно:
//      void uos_init()
//      {
//          manuf_spi_init(&spim, ...);
//          ...
//      }
// 3) Объявить переменную сообщения SPI. Проинициализировать её поля и вызвать
// функцию spim_trx:
//
//      spi_message_t msg;
//      uint8_t rxbuf[16];  // буфер для принятых данных
//      uint8_t txbuf[16];  // буфер для выдаваемых данных
//
//      ...
//
//      msg.rx_data = rxbuf;
//      msg.tx_data = txbuf;
//      msg.word_count = 16;
//      msg.freq = 4000000; // битовая скорость в герцах
//      msg.mode = SPI_MODE_CPHA | SPI_MODE_NB_BITS(8); // это для примера
//
//      spim_trx((spimif_t *) &spim, &msg);
//
// Возможные установки режима приёма-передачи приведены ниже в данном файле.
// Поля rx_data и tx_data сообщения могут быть нулевыми, если, соответственно,
// принятые данные не представляют интереса или передаваемые данные могут быть
// просто нулевыми.
//


//
// Коды результата
//

// Успешно
#define SPI_ERR_OK              0
// Возвращается в случае, если запрошенное количество битов в слове превышает 
// возможности драйвера.
#define SPI_ERR_BAD_BITS        -1
// Возвращается в случае, если запрошена неподдерживаемая драйвером
// скорость передачи (битовая частота).
#define SPI_ERR_BAD_FREQ        -2
// Возвращается, если запрошен не существующий номер линии выбора устройства
// ("чип-селекта").
#define SPI_ERR_BAD_CS          -3
// Возращается в случае невозможности передачи сообщения из-за его большой
// длины (недостаточный размер буфера в драйвере).
#define SPI_ERR_SMALL_BUF       -4
// Возвращается, если указан недопустимый номер порта (контроллера) SPI.
#define SPI_ERR_BAD_PORT        -5
// Возвращается, если запрошен неподдерживаемый режим передачи.
#define SPI_ERR_MODE_NOT_SUPP   -6


//
// Установки режима драйвера (для поля mode структуры spi_message_t)
//

// Полярность линии синхроимпульсов. Если флаг не задан, то в режиме ожидания
// линия переводится в низкий уровень; если задан, то в высокий.
#define SPI_MODE_CPOL           (1 << 0)
// Выбор фронта синхроимпульса, по которому осуществляется выборка данных.
// Если CPOL не задан, то при заданном CPHA - по заднему, при незаданном - по
// переднему. Если CPOL задан, то при заданном CPHA - по переднему, при
// незаданном - по заднему.
#define SPI_MODE_CPHA           (1 << 1)
// Выбор активного уровня линии выбора устройства. Если флаг не задан, то
// активный низкий, иначе активный высокий.
#define SPI_MODE_CS_HIGH        (1 << 2)
// Выбор порядка следования бит на линиях данных. Если флаг не задан, то
// первый передаётся старший бит, иначе младший бит.
#define SPI_MODE_LSB_FIRST      (1 << 3)
// Поведение линии выбора устройства после передачи сообщения. Если флаг не
// задан, то линия переходит в неактивное состояние автоматически. Иначе
// остаётся активным до передачи сообщения, в поле mode которого будет
// отсутствовать этот флаг.
#define SPI_MODE_CS_HOLD        (1 << 4)
// Макрос для извлечения флагов режима из поля mode структуры spi_message_t.
// Флагами режима считаются все вышеперечисленные флаги.
#define SPI_MODE_GET_MODE(x)    ((x) & 0xFF)
// Номер линии выборки устройства. Контроллер SPI, работающий в режиме 
// "Master" может иметь несколько линий выборки устройства, к каждой из
// которых может быть подключено одно устройство. Номер линии выборки
// задаётся в поле mode структуры spi_message_t с помощью CS_NUM.
#define SPI_MODE_CS_NUM(x)      ((x) << 8)
// Макрос для извлечения номера линии выборки устройства из поля 
// mode структуры spi_message_t
#define SPI_MODE_GET_CS_NUM(x)  (((x) >> 8) & 0xFF)
// Количество бит в одном слове.
#define SPI_MODE_NB_BITS(x)     ((x) << 16)
// Макрос для извлечения количества бит в слове из поля mode spi_message_t.
#define SPI_MODE_GET_NB_BITS(x) (((x) >> 16) & 0xFF)



#include <kernel/uos.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _spimif_t spimif_t;
typedef struct _spi_message_t spi_message_t;


//
// Базовый тип интерфейса SPI-Master
//
struct _spimif_t
{
    // Мьютекс для синхронизации
    mutex_t     lock;
    
    // Требование к выравниванию данных (к адресам tx_data и rx_data),
    // сообщаемое драйвером SPI-Master использующему его коду.
    // Должны соблюдаться равенства:
    // (unsigned) tx_data & data_align == 0
    // (unsigned) rx_data & data_align == 0
    // Иначе не гарантируются правильные приём и передача данных.
    unsigned	data_align;

    // В данное поле должен быть записан указатель на аппаратно-зависимую
    // функцию, выполняющую приём-передачу по интерфейсу spi сообщения msg.
    int (* trx)(spimif_t *spi, spi_message_t *msg);
};

#define to_spimif(x)   ((spimif_t*)&(x)->spimif)

//
// Структура сообщения SPI.
//
struct _spi_message_t {
    // Указатель на буфер с передаваемыми данными. Задать 0, если не 
    // требуется передавать каких-либо определённых данных (только приём).
    void        *tx_data;
    // Указатель на буфер для принимаемых данных. Задать 0, если не
    // требуется сохранять принимаемый массив (только передача).
    void        *rx_data;
    // Количество слов в сообщении.
    unsigned    word_count;
    // Требуемая частота передачи (битовая скорость)
    unsigned    freq;
    // Установки для передачи сообщения.
    unsigned    mode;
};

//
// Функция-обёрка для удобства вызова функции приёма-передачи.
//
static inline __attribute__((always_inline)) 
int spim_trx(spimif_t *spi, spi_message_t *msg)
{
    return spi->trx(spi, msg);
}



#ifdef __cplusplus
}
#endif

#endif // __SPI_MASTER_INTERFACE_H__
